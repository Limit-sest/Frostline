<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Frostline</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #f0f8ff;
      }

      canvas {
        display: block;
        cursor: crosshair;

        width: 512px;
        height: 512px;

        image-rendering: pixelated;
        image-rendering: crisp-edges;
        border: solid 2px black;
      }

      .icons {
        margin-top: 12px;
        display: flex;
        gap: 8px;
      }
      .icons button {
        border-radius: 0px;
        display: flex;
        justify-items: center;
        align-items: center;
        padding: 4px;
        cursor: pointer;
        background-color: hsl(0 0 90);
        border-color: hsl(0 0 70) hsl(0 0 50) hsl(0 0 70) hsl(0 0 50);
      }

      /*for color "icon"*/
      .icons button > div {
        width: 30px;
        height: 30px;
        border: solid black 3px;
        box-sizing: border-box;
        margin: 1px;
      }

      .icons button:hover {
        background-color: hsl(0 0 80);
        border-color: hsl(0 0 60) hsl(0 0 40) hsl(0 0 60) hsl(0 0 40);
      }

      .icons button.active {
        background-color: hsl(0 0 70);
        border-color: hsl(0 0 30) hsl(0 0 50) hsl(0 0 30) hsl(0 0 50);
      }

      .icons button img {
        image-rendering: pixelated;
        width: 32px;
        height: 32px;
      }
      .divider {
        height: 44px;
        border-left: solid dimgray 2px;
        margin: 0px 4px;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <div class="icons">
      <button id="pen" class="active" title="Pen tool">
        <img src="/assets/pen.png" alt="" />
      </button>
      <button id="rubber" title="Rubber tool">
        <img src="/assets/rubber.png" alt="" />
      </button>
      <button id="line" title="Line tool">
        <img src="/assets/line.png" alt="" />
      </button>
      <button id="bucket" title="Bucket tool">
        <img src="/assets/bucket.png" alt="" />
      </button>
      <div class="divider"></div>
      <button id="size1" class="active" title="Set brush size">
        <img src="/assets/size1.png" alt="" />
      </button>
      <button id="size2" title="Set brush size">
        <img src="/assets/size2.png" alt="" />
      </button>
      <button id="size3" title="Set brush size">
        <img src="/assets/size3.png" alt="" />
      </button>
      <div class="divider"></div>
      <button class="color-btn active" title="Select color">
        <div style="background-color: #52357b"></div>
      </button>
      <button class="color-btn" title="Select color">
        <div style="background-color: #5459ac"></div>
      </button>
      <button class="color-btn" title="Select color">
        <div style="background-color: #648db3"></div>
      </button>
      <button class="color-btn" title="Select color">
        <div style="background-color: #b2d8ce"></div>
      </button>
    </div>
    <script src="http://localhost:3000/socket.io/socket.io.js"></script>
    <script>
      const socket = io("localhost:3000");
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      let drawBuffer = [];
      let willSendBuffer = false;
      const colors = ["#52357B", "#5459AC", "#648DB3", "#B2D8CE"];
      let currentColor = 0;
      let activeTool = "pen";
      let thickness = 1;
      let lineStartX = 0;
      let lineStartY = 0;
      let previewImageData = null;

      const RESOLUTION = 256;
      canvas.width = RESOLUTION;
      canvas.height = RESOLUTION;

      ctx.imageSmoothingEnabled = false;
      ctx.fillStyle = colors[currentColor]; // draw color

      let isDrawing = false;
      let lastX = 0;
      let lastY = 0;

      function drawPixel(x, y, color = currentColor, emit = false) {
        if (color === -1) {
          ctx.clearRect(x, y, 1, 1);
        } else {
          ctx.fillRect(x, y, 1, 1);
        }

        if (emit) {
          drawBuffer.push({ x: x, y: y, color: color });
          if (!willSendBuffer) {
            willSendBuffer = true;
            setTimeout(sendBuffer, 32);
          }
        }
      }

      function sendBuffer() {
        willSendBuffer = false;
        if (sendBuffer) socket.emit("drawBatch", drawBuffer);
        drawBuffer = [];
      }

      function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();

        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        return {
          x: Math.floor((evt.clientX - rect.left) * scaleX),
          y: Math.floor((evt.clientY - rect.top) * scaleY),
        };
      }

      socket.on("sync", (data) => {
        data.forEach((pixel) => {
          drawPixel(pixel.x, pixel.y, pixel.color);
        });
      });

      socket.on("draw", (pixel) => {
        drawPixel(pixel.x, pixel.y, pixel.color);
      });

      socket.on("drawBatch", (data) => {
        data.forEach((pixel) => {
          drawPixel(pixel.x, pixel.y, pixel.color);
        });
      });

      function drawPixelLine(x0, y0, x1, y1, emit = true) {
        const dx = Math.abs(x1 - x0);
        const dy = Math.abs(y1 - y0);
        const sx = x0 < x1 ? 1 : -1;
        const sy = y0 < y1 ? 1 : -1;
        let err = dx - dy;

        const radius = Math.floor(thickness / 2);

        while (true) {
          for (let i = -radius; i <= radius; i++) {
            if (dx > dy) {
              drawPixel(x0, y0 + i, undefined, emit);
            } else {
              drawPixel(x0 + i, y0, undefined, emit);
            }
          }
          if (x0 === x1 && y0 === y1) break;
          const e2 = 2 * err;
          if (e2 > -dy) {
            err -= dy;
            x0 += sx;
          }
          if (e2 < dx) {
            err += dx;
            y0 += sy;
          }
        }
      }

      function floodFill(startX, startY, targetColor) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const pixels = imageData.data;

        const startIndex = (startY * canvas.width + startX) * 4;
        const startR = pixels[startIndex];
        const startG = pixels[startIndex + 1];
        const startB = pixels[startIndex + 2];
        const startA = pixels[startIndex + 3];

        // Convert fill color to RGB
        const fillColor = colors[targetColor];
        const temp = document.createElement("canvas");
        const tempCtx = temp.getContext("2d");
        tempCtx.fillStyle = fillColor;
        tempCtx.fillRect(0, 0, 1, 1);
        const fillData = tempCtx.getImageData(0, 0, 1, 1).data;

        // if clicked same color return
        if (
          startR === fillData[0] &&
          startG === fillData[1] &&
          startB === fillData[2]
        ) {
          return;
        }

        const pixelsToFill = [];
        const queue = [[startX, startY]];
        const visited = new Set();

        while (queue.length > 0) {
          const [x, y] = queue.shift();
          const key = `${x},${y}`;

          if (visited.has(key)) continue;
          if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height)
            continue;

          const index = (y * canvas.width + x) * 4;
          const r = pixels[index];
          const g = pixels[index + 1];
          const b = pixels[index + 2];
          const a = pixels[index + 3];

          // Check if pixel matches target color
          if (r !== startR || g !== startG || b !== startB || a !== startA)
            continue;

          visited.add(key);
          pixelsToFill.push({ x, y, color: targetColor });

          // Add neighbors to queue
          queue.push([x + 1, y]);
          queue.push([x - 1, y]);
          queue.push([x, y + 1]);
          queue.push([x, y - 1]);
        }

        // Draw all pixels
        pixelsToFill.forEach((pixel) => {
          drawPixel(pixel.x, pixel.y, pixel.color, true);
        });
      }

      function startDrawing(e) {
        const pos = getMousePos(e);

        if (activeTool === "bucket") {
          floodFill(pos.x, pos.y, currentColor);
          return;
        }

        isDrawing = true;
        lastX = pos.x;
        lastY = pos.y;

        if (activeTool === "line") {
          lineStartX = pos.x;
          lineStartY = pos.y;
          previewImageData = ctx.getImageData(
            0,
            0,
            canvas.width,
            canvas.height,
          );
        } else {
          // Draw a single dot on click
          drawPixel(pos.x, pos.y, undefined, true);
        }
      }

      function stopDrawing(e) {
        if (isDrawing && activeTool === "line") {
          const pos = getMousePos(e);
          ctx.putImageData(previewImageData, 0, 0);
          drawPixelLine(lineStartX, lineStartY, pos.x, pos.y, true);
          previewImageData = null;
        }
        isDrawing = false;
      }

      function draw(e) {
        if (!isDrawing) return;

        const pos = getMousePos(e);

        if (activeTool === "line") {
          ctx.putImageData(previewImageData, 0, 0);
          drawPixelLine(lineStartX, lineStartY, pos.x, pos.y, false);
        } else {
          drawPixelLine(lastX, lastY, pos.x, pos.y, true);

          lastX = pos.x;
          lastY = pos.y;
        }
      }

      canvas.addEventListener("mousedown", startDrawing);
      canvas.addEventListener("mousemove", draw);
      canvas.addEventListener("mouseup", stopDrawing);
      canvas.addEventListener("mouseout", () => {
        isDrawing = false;
      });

      // TOOLBAR
      const pen = document.getElementById("pen");
      const rubber = document.getElementById("rubber");
      const line = document.getElementById("line");
      const bucket = document.getElementById("bucket");
      const size1 = document.getElementById("size1");
      const size2 = document.getElementById("size2");
      const size3 = document.getElementById("size3");

      const colorButtons = document.querySelectorAll(".color-btn");
      const tools = [pen, rubber, line, bucket];
      const sizes = [size1, size2, size3];

      function resetActive(group) {
        group.forEach((element) => {
          element.classList.remove("active");
          element.disabled = false;
        });
      }

      pen.addEventListener("click", () => {
        currentColor = 0;
        activeTool = "pen";
        resetActive(tools);
        colorButtons.forEach((button) => {
          button.disabled = false;
        });
        pen.classList.add("active");
        pen.disabled = true;
      });
      rubber.addEventListener("click", () => {
        currentColor = -1;
        activeTool = "rubber";
        resetActive(tools);
        colorButtons.forEach((button) => {
          button.disabled = true;
        });
        rubber.classList.add("active");
        rubber.disabled = true;
      });
      line.addEventListener("click", () => {
        currentColor = 0;
        activeTool = "line";
        resetActive(tools);
        colorButtons.forEach((button) => {
          button.disabled = false;
        });
        line.classList.add("active");
        line.disabled = true;
      });
      bucket.addEventListener("click", () => {
        currentColor = 0;
        activeTool = "bucket";
        resetActive(tools);
        colorButtons.forEach((button) => {
          button.disabled = false;
        });
        bucket.classList.add("active");
        bucket.disabled = true;
      });
      size1.addEventListener("click", () => {
        thickness = 1;
        resetActive(sizes);
        size1.classList.add("active");
        size1.disabled = true;
      });
      size2.addEventListener("click", () => {
        thickness = 2;
        resetActive(sizes);
        size2.classList.add("active");
        size2.disabled = true;
      });
      size3.addEventListener("click", () => {
        thickness = 4;
        resetActive(sizes);
        size3.classList.add("active");
        size3.disabled = true;
      });

      colorButtons.forEach((button, index) => {
        button.addEventListener("click", () => {
          currentColor = index;
          ctx.fillStyle = colors[currentColor];
          resetActive(colorButtons);
          button.classList.add("active");
          button.disabled = true;
        });
      });
    </script>
  </body>
</html>
