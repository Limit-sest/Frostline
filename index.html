<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Frostline</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #f0f8ff;
      }

      canvas {
        display: block;
        cursor: crosshair;

        width: 600px;
        height: 600px;

        image-rendering: pixelated;
        image-rendering: crisp-edges;
        border: solid 2px black;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script src="http://localhost:3000/socket.io/socket.io.js"></script>
    <script>
      const socket = io("localhost:3000");
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      let drawBuffer = [];
      let willSendBuffer = false;
      const colors = ["#1A237E"];
      let currentColor = 0;

      const RESOLUTION = 200;
      canvas.width = RESOLUTION;
      canvas.height = RESOLUTION;

      ctx.imageSmoothingEnabled = false;
      ctx.fillStyle = colors[currentColor]; // draw color

      let isDrawing = false;
      let lastX = 0;
      let lastY = 0;

      function drawPixel(x, y, color = currentColor, emit = false) {
        if (color === -1) {
          ctx.clearRect(x, y, 1, 1);
        } else {
          ctx.fillRect(x, y, 1, 1);
        }

        if (emit) {
          drawBuffer.push({ x: x, y: y, color: color });
          if (!willSendBuffer) {
            willSendBuffer = true;
            setTimeout(sendBuffer, 32);
          }
        }
      }

      function sendBuffer() {
        willSendBuffer = false;
        if (sendBuffer) socket.emit("drawBatch", drawBuffer);
        drawBuffer = [];
      }

      function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();

        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        return {
          x: Math.floor((evt.clientX - rect.left) * scaleX),
          y: Math.floor((evt.clientY - rect.top) * scaleY),
        };
      }

      socket.on("sync", (data) => {
        data.forEach((pixel) => {
          drawPixel(pixel.x, pixel.y, pixel.color);
        });
      });

      socket.on("draw", (pixel) => {
        drawPixel(pixel.x, pixel.y, pixel.color);
      });

      socket.on("drawBatch", (data) => {
        data.forEach((pixel) => {
          drawPixel(pixel.x, pixel.y, pixel.color);
        });
      });

      function drawPixelLine(x0, y0, x1, y1) {
        const dx = Math.abs(x1 - x0);
        const dy = Math.abs(y1 - y0);
        const sx = x0 < x1 ? 1 : -1;
        const sy = y0 < y1 ? 1 : -1;
        let err = dx - dy;

        while (true) {
          drawPixel(x0, y0, undefined, true);

          if (x0 === x1 && y0 === y1) break;
          const e2 = 2 * err;
          if (e2 > -dy) {
            err -= dy;
            x0 += sx;
          }
          if (e2 < dx) {
            err += dx;
            y0 += sy;
          }
        }
      }

      function startDrawing(e) {
        isDrawing = true;
        const pos = getMousePos(e);
        lastX = pos.x;
        lastY = pos.y;

        // Draw a single dot on click
        drawPixel(pos.x, pos.y, undefined, true);
      }

      function stopDrawing() {
        isDrawing = false;
      }

      function draw(e) {
        if (!isDrawing) return;

        const pos = getMousePos(e);
        drawPixelLine(lastX, lastY, pos.x, pos.y);

        lastX = pos.x;
        lastY = pos.y;
      }

      canvas.addEventListener("mousedown", startDrawing);
      canvas.addEventListener("mousemove", draw);
      canvas.addEventListener("mouseup", stopDrawing);
      canvas.addEventListener("mouseout", stopDrawing);
    </script>
  </body>
</html>
